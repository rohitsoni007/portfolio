// Auto-generated blog data - DO NOT EDIT MANUALLY
// Generated at: 2025-11-03T14:46:44.587Z

import type { BlogPost } from './constants';

export const BLOG_POSTS_DATA: BlogPost[] = [
  {
    "id": "building-scalable-apis-with-expressjs",
    "title": "Building Scalable APIs with Express.js",
    "excerpt": "Brief description of your blog post...",
    "content": "# Building Scalable APIs with Express.js\n\nWrite your blog post content here using Markdown syntax.\n\n## Introduction\n\nStart with an engaging introduction that hooks your readers.\n\n## Main Content\n\nAdd your main content sections here.\n\n### Subsection\n\nYou can use various markdown features:\n\n- **Bold text**\n- *Italic text*\n- `inline code`\n- [Links](https://example.com)\n\n### Code Examples\n\n```javascript\n// Add code examples\nfunction example() {\n  console.log('Hello, World!');\n}\n```\n\n### Lists\n\n1. Numbered lists\n2. Are also supported\n3. Like this\n\n## Conclusion\n\nWrap up your post with a strong conclusion.\n",
    "author": "Rohit Soni",
    "publishedAt": "2025-11-03",
    "readTime": 5,
    "tags": [
      "Tag1",
      "Tag2",
      "Tag3"
    ],
    "featured": false,
    "image": "optional-image.jpg"
  },
  {
    "id": "getting-started-with-react-native",
    "title": "Getting Started with React Native: A Complete Guide",
    "excerpt": "Learn how to build your first React Native app from scratch. This comprehensive guide covers setup, navigation, and best practices for mobile development.",
    "content": "# Getting Started with React Native: A Complete Guide\r\n\r\nReact Native has revolutionized mobile app development by allowing developers to build native mobile applications using JavaScript and React. In this comprehensive guide, we'll walk through everything you need to know to get started with React Native development.\r\n\r\n## What is React Native?\r\n\r\nReact Native is an open-source framework developed by Facebook that enables developers to build mobile applications using React and JavaScript. Unlike hybrid apps that run in a WebView, React Native apps compile to native code, providing near-native performance and user experience.\r\n\r\n## Setting Up Your Development Environment\r\n\r\nBefore we start building our first React Native app, we need to set up our development environment. Here's what you'll need:\r\n\r\n### Prerequisites\r\n- Node.js (version 14 or higher)\r\n- npm or yarn package manager\r\n- Android Studio (for Android development)\r\n- Xcode (for iOS development - macOS only)\r\n\r\n### Installation Steps\r\n\r\n1. **Install React Native CLI**\r\n   ```bash\r\n   npm install -g react-native-cli\r\n   ```\r\n\r\n2. **Create a new React Native project**\r\n   ```bash\r\n   npx react-native init MyFirstApp\r\n   cd MyFirstApp\r\n   ```\r\n\r\n3. **Run your app**\r\n   ```bash\r\n   # For Android\r\n   npx react-native run-android\r\n   \r\n   # For iOS (macOS only)\r\n   npx react-native run-ios\r\n   ```\r\n\r\n## Understanding the Project Structure\r\n\r\nWhen you create a new React Native project, you'll see several important files and folders:\r\n\r\n- **App.js**: The main component of your application\r\n- **android/**: Contains Android-specific code and configuration\r\n- **ios/**: Contains iOS-specific code and configuration\r\n- **node_modules/**: Contains all the npm packages\r\n- **package.json**: Lists dependencies and scripts\r\n\r\n## Building Your First Component\r\n\r\nLet's create a simple component to understand React Native basics:\r\n\r\n```javascript\r\nimport React from 'react';\r\nimport { View, Text, StyleSheet, TouchableOpacity } from 'react-native';\r\n\r\nconst WelcomeScreen = () => {\r\n  const handlePress = () => {\r\n    alert('Hello React Native!');\r\n  };\r\n\r\n  return (\r\n    <View style={styles.container}>\r\n      <Text style={styles.title}>Welcome to React Native</Text>\r\n      <TouchableOpacity style={styles.button} onPress={handlePress}>\r\n        <Text style={styles.buttonText}>Press Me</Text>\r\n      </TouchableOpacity>\r\n    </View>\r\n  );\r\n};\r\n\r\nconst styles = StyleSheet.create({\r\n  container: {\r\n    flex: 1,\r\n    justifyContent: 'center',\r\n    alignItems: 'center',\r\n    backgroundColor: '#f5f5f5',\r\n  },\r\n  title: {\r\n    fontSize: 24,\r\n    fontWeight: 'bold',\r\n    marginBottom: 20,\r\n    color: '#333',\r\n  },\r\n  button: {\r\n    backgroundColor: '#007AFF',\r\n    paddingHorizontal: 20,\r\n    paddingVertical: 10,\r\n    borderRadius: 8,\r\n  },\r\n  buttonText: {\r\n    color: 'white',\r\n    fontSize: 16,\r\n    fontWeight: '600',\r\n  },\r\n});\r\n\r\nexport default WelcomeScreen;\r\n```\r\n\r\n## Navigation in React Native\r\n\r\nNavigation is crucial for mobile apps. React Navigation is the most popular navigation library:\r\n\r\n```bash\r\nnpm install @react-navigation/native @react-navigation/stack\r\nnpm install react-native-screens react-native-safe-area-context\r\n```\r\n\r\n## Best Practices\r\n\r\n1. **Use TypeScript**: Adds type safety and better development experience\r\n2. **Follow naming conventions**: Use PascalCase for components, camelCase for functions\r\n3. **Optimize performance**: Use FlatList for large lists, avoid unnecessary re-renders\r\n4. **Test on real devices**: Simulators don't always reflect real device behavior\r\n5. **Handle different screen sizes**: Design responsive layouts\r\n\r\n## Common Challenges and Solutions\r\n\r\n### Performance Issues\r\n- Use `React.memo` for expensive components\r\n- Implement proper list virtualization\r\n- Optimize images and assets\r\n\r\n### Platform Differences\r\n- Use Platform.OS to handle platform-specific code\r\n- Test thoroughly on both iOS and Android\r\n- Consider platform-specific design guidelines\r\n\r\n## Conclusion\r\n\r\nReact Native offers an excellent way to build mobile applications with a single codebase. While there's a learning curve, the benefits of code reusability and faster development cycles make it an attractive choice for many projects.\r\n\r\nStart with simple projects, gradually add complexity, and don't hesitate to dive into native code when needed. The React Native community is vibrant and helpful, so you'll find plenty of resources and support along your journey.\r\n\r\nHappy coding!",
    "author": "Rohit Soni",
    "publishedAt": "2024-01-15",
    "readTime": 8,
    "tags": [
      "React Native",
      "Mobile Development",
      "JavaScript",
      "Tutorial"
    ],
    "featured": 1,
    "image": "react-native-guide.jpg"
  },
  {
    "id": "mern-stack-best-practices",
    "title": "MERN Stack Best Practices for Scalable Applications",
    "excerpt": "Discover essential best practices for building scalable MERN stack applications. Learn about project structure, security, performance optimization, and deployment strategies.",
    "content": "# MERN Stack Best Practices for Scalable Applications\r\n\r\nThe MERN stack (MongoDB, Express.js, React, Node.js) has become one of the most popular choices for building modern web applications. However, building scalable and maintainable MERN applications requires following certain best practices. In this post, we'll explore the essential practices that will help you build robust applications.\r\n\r\n## Project Structure and Organization\r\n\r\nA well-organized project structure is the foundation of any scalable application. Here's a recommended structure for MERN applications:\r\n\r\n```\r\nproject-root/\r\n├── client/                 # React frontend\r\n│   ├── public/\r\n│   ├── src/\r\n│   │   ├── components/\r\n│   │   ├── pages/\r\n│   │   ├── hooks/\r\n│   │   ├── utils/\r\n│   │   ├── services/\r\n│   │   └── styles/\r\n│   └── package.json\r\n├── server/                 # Node.js backend\r\n│   ├── controllers/\r\n│   ├── models/\r\n│   ├── routes/\r\n│   ├── middleware/\r\n│   ├── utils/\r\n│   ├── config/\r\n│   └── package.json\r\n├── shared/                 # Shared utilities/types\r\n└── README.md\r\n```\r\n\r\n## Backend Best Practices\r\n\r\n### 1. Environment Configuration\r\n\r\nAlways use environment variables for configuration:\r\n\r\n```javascript\r\n// config/database.js\r\nconst mongoose = require('mongoose');\r\n\r\nconst connectDB = async () => {\r\n  try {\r\n    const conn = await mongoose.connect(process.env.MONGODB_URI, {\r\n      useNewUrlParser: true,\r\n      useUnifiedTopology: true,\r\n    });\r\n    console.log(`MongoDB Connected: ${conn.connection.host}`);\r\n  } catch (error) {\r\n    console.error(error);\r\n    process.exit(1);\r\n  }\r\n};\r\n\r\nmodule.exports = connectDB;\r\n```\r\n\r\n### 2. Error Handling Middleware\r\n\r\nImplement centralized error handling:\r\n\r\n```javascript\r\n// middleware/errorHandler.js\r\nconst errorHandler = (err, req, res, next) => {\r\n  let error = { ...err };\r\n  error.message = err.message;\r\n\r\n  // Log error\r\n  console.error(err);\r\n\r\n  // Mongoose bad ObjectId\r\n  if (err.name === 'CastError') {\r\n    const message = 'Resource not found';\r\n    error = { message, statusCode: 404 };\r\n  }\r\n\r\n  // Mongoose duplicate key\r\n  if (err.code === 11000) {\r\n    const message = 'Duplicate field value entered';\r\n    error = { message, statusCode: 400 };\r\n  }\r\n\r\n  // Mongoose validation error\r\n  if (err.name === 'ValidationError') {\r\n    const message = Object.values(err.errors).map(val => val.message);\r\n    error = { message, statusCode: 400 };\r\n  }\r\n\r\n  res.status(error.statusCode || 500).json({\r\n    success: false,\r\n    error: error.message || 'Server Error'\r\n  });\r\n};\r\n\r\nmodule.exports = errorHandler;\r\n```\r\n\r\n### 3. Input Validation\r\n\r\nUse libraries like Joi or express-validator:\r\n\r\n```javascript\r\nconst { body, validationResult } = require('express-validator');\r\n\r\nconst validateUser = [\r\n  body('email').isEmail().normalizeEmail(),\r\n  body('password').isLength({ min: 6 }),\r\n  body('name').trim().isLength({ min: 2 }),\r\n  (req, res, next) => {\r\n    const errors = validationResult(req);\r\n    if (!errors.isEmpty()) {\r\n      return res.status(400).json({ errors: errors.array() });\r\n    }\r\n    next();\r\n  }\r\n];\r\n```\r\n\r\n## Frontend Best Practices\r\n\r\n### 1. Component Organization\r\n\r\nKeep components small and focused:\r\n\r\n```javascript\r\n// components/UserCard/UserCard.jsx\r\nimport React from 'react';\r\nimport './UserCard.css';\r\n\r\nconst UserCard = ({ user, onEdit, onDelete }) => {\r\n  return (\r\n    <div className=\"user-card\">\r\n      <img src={user.avatar} alt={user.name} />\r\n      <h3>{user.name}</h3>\r\n      <p>{user.email}</p>\r\n      <div className=\"actions\">\r\n        <button onClick={() => onEdit(user.id)}>Edit</button>\r\n        <button onClick={() => onDelete(user.id)}>Delete</button>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default UserCard;\r\n```\r\n\r\n### 2. State Management\r\n\r\nUse Context API for global state or Redux for complex applications:\r\n\r\n```javascript\r\n// context/AuthContext.js\r\nimport React, { createContext, useContext, useReducer } from 'react';\r\n\r\nconst AuthContext = createContext();\r\n\r\nconst authReducer = (state, action) => {\r\n  switch (action.type) {\r\n    case 'LOGIN_SUCCESS':\r\n      return {\r\n        ...state,\r\n        user: action.payload,\r\n        isAuthenticated: true,\r\n        loading: false\r\n      };\r\n    case 'LOGOUT':\r\n      return {\r\n        ...state,\r\n        user: null,\r\n        isAuthenticated: false,\r\n        loading: false\r\n      };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\nexport const AuthProvider = ({ children }) => {\r\n  const [state, dispatch] = useReducer(authReducer, {\r\n    user: null,\r\n    isAuthenticated: false,\r\n    loading: true\r\n  });\r\n\r\n  return (\r\n    <AuthContext.Provider value={{ ...state, dispatch }}>\r\n      {children}\r\n    </AuthContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useAuth = () => useContext(AuthContext);\r\n```\r\n\r\n## Security Best Practices\r\n\r\n### 1. Authentication and Authorization\r\n\r\nImplement JWT-based authentication:\r\n\r\n```javascript\r\n// middleware/auth.js\r\nconst jwt = require('jsonwebtoken');\r\nconst User = require('../models/User');\r\n\r\nconst protect = async (req, res, next) => {\r\n  let token;\r\n\r\n  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {\r\n    token = req.headers.authorization.split(' ')[1];\r\n  }\r\n\r\n  if (!token) {\r\n    return res.status(401).json({ message: 'Not authorized to access this route' });\r\n  }\r\n\r\n  try {\r\n    const decoded = jwt.verify(token, process.env.JWT_SECRET);\r\n    req.user = await User.findById(decoded.id);\r\n    next();\r\n  } catch (error) {\r\n    return res.status(401).json({ message: 'Not authorized to access this route' });\r\n  }\r\n};\r\n\r\nmodule.exports = { protect };\r\n```\r\n\r\n### 2. Data Sanitization\r\n\r\nSanitize user input to prevent XSS and injection attacks:\r\n\r\n```javascript\r\nconst mongoSanitize = require('express-mongo-sanitize');\r\nconst xss = require('xss-clean');\r\nconst hpp = require('hpp');\r\n\r\napp.use(mongoSanitize());\r\napp.use(xss());\r\napp.use(hpp());\r\n```\r\n\r\n## Performance Optimization\r\n\r\n### 1. Database Optimization\r\n\r\nUse proper indexing and aggregation:\r\n\r\n```javascript\r\n// models/User.js\r\nconst userSchema = new mongoose.Schema({\r\n  email: {\r\n    type: String,\r\n    required: true,\r\n    unique: true,\r\n    index: true\r\n  },\r\n  name: {\r\n    type: String,\r\n    required: true,\r\n    index: true\r\n  },\r\n  createdAt: {\r\n    type: Date,\r\n    default: Date.now,\r\n    index: true\r\n  }\r\n});\r\n\r\n// Compound index for common queries\r\nuserSchema.index({ email: 1, createdAt: -1 });\r\n```\r\n\r\n### 2. Frontend Optimization\r\n\r\nImplement code splitting and lazy loading:\r\n\r\n```javascript\r\nimport React, { Suspense, lazy } from 'react';\r\n\r\nconst Dashboard = lazy(() => import('./components/Dashboard'));\r\nconst Profile = lazy(() => import('./components/Profile'));\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Suspense fallback={<div>Loading...</div>}>\r\n        <Routes>\r\n          <Route path=\"/dashboard\" element={<Dashboard />} />\r\n          <Route path=\"/profile\" element={<Profile />} />\r\n        </Routes>\r\n      </Suspense>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n## Testing Strategies\r\n\r\n### Backend Testing\r\n\r\n```javascript\r\n// tests/auth.test.js\r\nconst request = require('supertest');\r\nconst app = require('../app');\r\n\r\ndescribe('Auth Endpoints', () => {\r\n  test('Should register a new user', async () => {\r\n    const response = await request(app)\r\n      .post('/api/auth/register')\r\n      .send({\r\n        name: 'Test User',\r\n        email: 'test@example.com',\r\n        password: 'password123'\r\n      });\r\n    \r\n    expect(response.status).toBe(201);\r\n    expect(response.body.success).toBe(true);\r\n  });\r\n});\r\n```\r\n\r\n### Frontend Testing\r\n\r\n```javascript\r\n// components/__tests__/UserCard.test.js\r\nimport { render, screen, fireEvent } from '@testing-library/react';\r\nimport UserCard from '../UserCard';\r\n\r\ntest('renders user information', () => {\r\n  const user = {\r\n    id: 1,\r\n    name: 'John Doe',\r\n    email: 'john@example.com',\r\n    avatar: 'avatar.jpg'\r\n  };\r\n\r\n  render(<UserCard user={user} onEdit={jest.fn()} onDelete={jest.fn()} />);\r\n  \r\n  expect(screen.getByText('John Doe')).toBeInTheDocument();\r\n  expect(screen.getByText('john@example.com')).toBeInTheDocument();\r\n});\r\n```\r\n\r\n## Deployment Best Practices\r\n\r\n### 1. Environment Setup\r\n\r\nUse different configurations for different environments:\r\n\r\n```javascript\r\n// config/config.js\r\nmodule.exports = {\r\n  development: {\r\n    database: process.env.DEV_DATABASE_URL,\r\n    jwtSecret: process.env.DEV_JWT_SECRET,\r\n  },\r\n  production: {\r\n    database: process.env.DATABASE_URL,\r\n    jwtSecret: process.env.JWT_SECRET,\r\n  }\r\n};\r\n```\r\n\r\n### 2. Docker Configuration\r\n\r\n```dockerfile\r\n# Dockerfile\r\nFROM node:16-alpine\r\n\r\nWORKDIR /app\r\n\r\nCOPY package*.json ./\r\nRUN npm ci --only=production\r\n\r\nCOPY . .\r\n\r\nEXPOSE 5000\r\n\r\nCMD [\"npm\", \"start\"]\r\n```\r\n\r\n## Conclusion\r\n\r\nBuilding scalable MERN applications requires attention to detail in project structure, security, performance, and deployment. By following these best practices, you'll create applications that are maintainable, secure, and performant.\r\n\r\nRemember that these practices should be adapted to your specific use case and requirements. Start with the basics and gradually implement more advanced patterns as your application grows.",
    "author": "Rohit Soni",
    "publishedAt": "2024-01-10",
    "readTime": 12,
    "tags": [
      "MERN Stack",
      "Best Practices",
      "Node.js",
      "React",
      "MongoDB"
    ],
    "featured": 1,
    "image": "mern-best-practices.jpg"
  },
  {
    "id": "typescript-react-development",
    "title": "Why TypeScript is Essential for Modern React Development",
    "excerpt": "Explore the benefits of using TypeScript with React and learn how it can improve your development experience, catch bugs early, and make your code more maintainable.",
    "content": "# Why TypeScript is Essential for Modern React Development\r\n\r\nTypeScript has become increasingly popular in the React ecosystem, and for good reason. In this post, we'll explore why TypeScript is essential for modern React development and how it can significantly improve your development experience.\r\n\r\n## What is TypeScript?\r\n\r\nTypeScript is a superset of JavaScript that adds static type definitions. It compiles to plain JavaScript and runs anywhere JavaScript runs. Think of it as JavaScript with superpowers – it provides all the features of JavaScript plus additional features like static typing, interfaces, and advanced IDE support.\r\n\r\n## Benefits of Using TypeScript with React\r\n\r\n### 1. Early Bug Detection\r\n\r\nOne of the most significant advantages of TypeScript is its ability to catch errors at compile time rather than runtime:\r\n\r\n```typescript\r\n// Without TypeScript - Runtime error\r\nfunction greetUser(user) {\r\n  return `Hello, ${user.name}!`;\r\n}\r\n\r\ngreetUser(null); // Runtime error: Cannot read property 'name' of null\r\n\r\n// With TypeScript - Compile-time error\r\ninterface User {\r\n  name: string;\r\n  email: string;\r\n}\r\n\r\nfunction greetUser(user: User): string {\r\n  return `Hello, ${user.name}!`;\r\n}\r\n\r\ngreetUser(null); // TypeScript error: Argument of type 'null' is not assignable\r\n```\r\n\r\n### 2. Better IDE Support\r\n\r\nTypeScript provides excellent IntelliSense, auto-completion, and refactoring capabilities:\r\n\r\n```typescript\r\ninterface Props {\r\n  title: string;\r\n  count: number;\r\n  onIncrement: () => void;\r\n  isLoading?: boolean;\r\n}\r\n\r\nconst Counter: React.FC<Props> = ({ title, count, onIncrement, isLoading = false }) => {\r\n  // IDE will provide auto-completion for all props\r\n  return (\r\n    <div>\r\n      <h2>{title}</h2>\r\n      <p>Count: {count}</p>\r\n      <button onClick={onIncrement} disabled={isLoading}>\r\n        {isLoading ? 'Loading...' : 'Increment'}\r\n      </button>\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\n### 3. Self-Documenting Code\r\n\r\nTypeScript interfaces and types serve as documentation:\r\n\r\n```typescript\r\ninterface ApiResponse<T> {\r\n  data: T;\r\n  status: 'success' | 'error';\r\n  message?: string;\r\n  timestamp: Date;\r\n}\r\n\r\ninterface User {\r\n  id: number;\r\n  name: string;\r\n  email: string;\r\n  role: 'admin' | 'user' | 'moderator';\r\n  createdAt: Date;\r\n  lastLogin?: Date;\r\n}\r\n\r\n// The function signature tells you exactly what to expect\r\nasync function fetchUser(id: number): Promise<ApiResponse<User>> {\r\n  // Implementation\r\n}\r\n```\r\n\r\n## Setting Up TypeScript with React\r\n\r\n### 1. Create React App with TypeScript\r\n\r\n```bash\r\nnpx create-react-app my-app --template typescript\r\n```\r\n\r\n### 2. Adding TypeScript to Existing Project\r\n\r\n```bash\r\nnpm install --save-dev typescript @types/react @types/react-dom\r\n```\r\n\r\n### 3. TypeScript Configuration\r\n\r\nCreate a `tsconfig.json` file:\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"es5\",\r\n    \"lib\": [\"dom\", \"dom.iterable\", \"es6\"],\r\n    \"allowJs\": true,\r\n    \"skipLibCheck\": true,\r\n    \"esModuleInterop\": true,\r\n    \"allowSyntheticDefaultImports\": true,\r\n    \"strict\": true,\r\n    \"forceConsistentCasingInFileNames\": true,\r\n    \"module\": \"esnext\",\r\n    \"moduleResolution\": \"node\",\r\n    \"resolveJsonModule\": true,\r\n    \"isolatedModules\": true,\r\n    \"noEmit\": true,\r\n    \"jsx\": \"react-jsx\"\r\n  },\r\n  \"include\": [\r\n    \"src\"\r\n  ]\r\n}\r\n```\r\n\r\n## Common TypeScript Patterns in React\r\n\r\n### 1. Component Props\r\n\r\n```typescript\r\n// Basic props interface\r\ninterface ButtonProps {\r\n  children: React.ReactNode;\r\n  onClick: () => void;\r\n  variant?: 'primary' | 'secondary';\r\n  disabled?: boolean;\r\n}\r\n\r\nconst Button: React.FC<ButtonProps> = ({ \r\n  children, \r\n  onClick, \r\n  variant = 'primary', \r\n  disabled = false \r\n}) => {\r\n  return (\r\n    <button \r\n      className={variant} \r\n      onClick={onClick} \r\n      disabled={disabled}\r\n    >\r\n      {children}\r\n    </button>\r\n  );\r\n};\r\n```\r\n\r\n### 2. State Management\r\n\r\n```typescript\r\n// Typed useState\r\nconst [user, setUser] = useState<User | null>(null);\r\nconst [loading, setLoading] = useState<boolean>(false);\r\nconst [errors, setErrors] = useState<string[]>([]);\r\n\r\n// Typed useReducer\r\ninterface State {\r\n  count: number;\r\n  loading: boolean;\r\n}\r\n\r\ntype Action = \r\n  | { type: 'INCREMENT' }\r\n  | { type: 'DECREMENT' }\r\n  | { type: 'SET_LOADING'; payload: boolean };\r\n\r\nconst reducer = (state: State, action: Action): State => {\r\n  switch (action.type) {\r\n    case 'INCREMENT':\r\n      return { ...state, count: state.count + 1 };\r\n    case 'DECREMENT':\r\n      return { ...state, count: state.count - 1 };\r\n    case 'SET_LOADING':\r\n      return { ...state, loading: action.payload };\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n```\r\n\r\n### 3. Custom Hooks\r\n\r\n```typescript\r\ninterface UseApiResult<T> {\r\n  data: T | null;\r\n  loading: boolean;\r\n  error: string | null;\r\n  refetch: () => void;\r\n}\r\n\r\nfunction useApi<T>(url: string): UseApiResult<T> {\r\n  const [data, setData] = useState<T | null>(null);\r\n  const [loading, setLoading] = useState<boolean>(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  const fetchData = useCallback(async () => {\r\n    try {\r\n      setLoading(true);\r\n      const response = await fetch(url);\r\n      const result = await response.json();\r\n      setData(result);\r\n    } catch (err) {\r\n      setError(err instanceof Error ? err.message : 'An error occurred');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [url]);\r\n\r\n  useEffect(() => {\r\n    fetchData();\r\n  }, [fetchData]);\r\n\r\n  return { data, loading, error, refetch: fetchData };\r\n}\r\n```\r\n\r\n### 4. Event Handlers\r\n\r\n```typescript\r\nconst handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n  setValue(event.target.value);\r\n};\r\n\r\nconst handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {\r\n  event.preventDefault();\r\n  // Handle form submission\r\n};\r\n\r\nconst handleButtonClick = (event: React.MouseEvent<HTMLButtonElement>) => {\r\n  console.log('Button clicked', event.currentTarget);\r\n};\r\n```\r\n\r\n## Advanced TypeScript Patterns\r\n\r\n### 1. Generic Components\r\n\r\n```typescript\r\ninterface ListProps<T> {\r\n  items: T[];\r\n  renderItem: (item: T) => React.ReactNode;\r\n  keyExtractor: (item: T) => string | number;\r\n}\r\n\r\nfunction List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {\r\n  return (\r\n    <ul>\r\n      {items.map(item => (\r\n        <li key={keyExtractor(item)}>\r\n          {renderItem(item)}\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  );\r\n}\r\n\r\n// Usage\r\n<List\r\n  items={users}\r\n  renderItem={(user) => <span>{user.name}</span>}\r\n  keyExtractor={(user) => user.id}\r\n/>\r\n```\r\n\r\n### 2. Utility Types\r\n\r\n```typescript\r\ninterface User {\r\n  id: number;\r\n  name: string;\r\n  email: string;\r\n  password: string;\r\n}\r\n\r\n// Pick specific properties\r\ntype PublicUser = Pick<User, 'id' | 'name' | 'email'>;\r\n\r\n// Omit specific properties\r\ntype CreateUserRequest = Omit<User, 'id'>;\r\n\r\n// Make all properties optional\r\ntype PartialUser = Partial<User>;\r\n\r\n// Make all properties required\r\ntype RequiredUser = Required<User>;\r\n```\r\n\r\n### 3. Discriminated Unions\r\n\r\n```typescript\r\ntype LoadingState = {\r\n  status: 'loading';\r\n};\r\n\r\ntype SuccessState = {\r\n  status: 'success';\r\n  data: User[];\r\n};\r\n\r\ntype ErrorState = {\r\n  status: 'error';\r\n  error: string;\r\n};\r\n\r\ntype ApiState = LoadingState | SuccessState | ErrorState;\r\n\r\nconst renderContent = (state: ApiState) => {\r\n  switch (state.status) {\r\n    case 'loading':\r\n      return <div>Loading...</div>;\r\n    case 'success':\r\n      return <div>{state.data.length} users loaded</div>;\r\n    case 'error':\r\n      return <div>Error: {state.error}</div>;\r\n  }\r\n};\r\n```\r\n\r\n## Best Practices\r\n\r\n### 1. Start Strict\r\n\r\nEnable strict mode in your TypeScript configuration:\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"strict\": true,\r\n    \"noImplicitAny\": true,\r\n    \"strictNullChecks\": true,\r\n    \"strictFunctionTypes\": true\r\n  }\r\n}\r\n```\r\n\r\n### 2. Use Meaningful Names\r\n\r\n```typescript\r\n// Good\r\ninterface UserProfileProps {\r\n  user: User;\r\n  onEdit: (userId: number) => void;\r\n  isEditable: boolean;\r\n}\r\n\r\n// Avoid\r\ninterface Props {\r\n  data: any;\r\n  onClick: Function;\r\n  flag: boolean;\r\n}\r\n```\r\n\r\n### 3. Leverage Type Guards\r\n\r\n```typescript\r\nfunction isUser(obj: any): obj is User {\r\n  return obj && typeof obj.id === 'number' && typeof obj.name === 'string';\r\n}\r\n\r\n// Usage\r\nif (isUser(data)) {\r\n  // TypeScript knows data is User type here\r\n  console.log(data.name);\r\n}\r\n```\r\n\r\n## Common Pitfalls and Solutions\r\n\r\n### 1. Any Type Abuse\r\n\r\n```typescript\r\n// Avoid\r\nconst data: any = fetchData();\r\n\r\n// Better\r\ninterface ApiResponse {\r\n  users: User[];\r\n  total: number;\r\n}\r\n\r\nconst data: ApiResponse = fetchData();\r\n```\r\n\r\n### 2. Missing Null Checks\r\n\r\n```typescript\r\n// Risky\r\nfunction getUserName(user: User | null) {\r\n  return user.name; // Potential runtime error\r\n}\r\n\r\n// Safe\r\nfunction getUserName(user: User | null) {\r\n  return user?.name ?? 'Unknown';\r\n}\r\n```\r\n\r\n## Conclusion\r\n\r\nTypeScript brings significant benefits to React development by providing type safety, better tooling, and improved code maintainability. While there's a learning curve, the investment pays off quickly through reduced bugs, better refactoring capabilities, and improved developer experience.\r\n\r\nStart by adding TypeScript to a small project or component, and gradually expand its usage. The React and TypeScript communities have created excellent resources and type definitions that make the integration seamless.\r\n\r\nRemember, TypeScript is not about writing more code – it's about writing better, more reliable code that scales with your application.",
    "author": "Rohit Soni",
    "publishedAt": "2024-01-05",
    "readTime": 10,
    "tags": [
      "TypeScript",
      "React",
      "JavaScript",
      "Development"
    ],
    "featured": false,
    "image": "typescript-react.jpg"
  },
  {
    "id": "nodejs-performance-optimization",
    "title": "Node.js Performance Optimization: Tips and Techniques",
    "excerpt": "Learn essential techniques to optimize your Node.js applications for better performance, including profiling, caching strategies, and database optimization.",
    "content": "# Node.js Performance Optimization: Tips and Techniques\r\n\r\nPerformance is crucial for any Node.js application, especially as your user base grows. In this comprehensive guide, we'll explore various techniques and strategies to optimize your Node.js applications for better performance, scalability, and user experience.\r\n\r\n## Understanding Node.js Performance\r\n\r\nNode.js is built on Chrome's V8 JavaScript engine and uses an event-driven, non-blocking I/O model. While this architecture provides excellent performance for I/O-intensive applications, there are still many ways to optimize your Node.js applications.\r\n\r\n## Profiling and Monitoring\r\n\r\nBefore optimizing, you need to identify performance bottlenecks. Here are some tools and techniques for profiling Node.js applications:\r\n\r\n### 1. Built-in Profiler\r\n\r\n```bash\r\n# Run your application with profiling\r\nnode --prof app.js\r\n\r\n# Process the profiling data\r\nnode --prof-process isolate-0x*.log > processed.txt\r\n```\r\n\r\n### 2. Using Clinic.js\r\n\r\n```bash\r\nnpm install -g clinic\r\n\r\n# Profile your application\r\nclinic doctor -- node app.js\r\nclinic bubbleprof -- node app.js\r\nclinic flame -- node app.js\r\n```\r\n\r\n### 3. Application Performance Monitoring\r\n\r\n```javascript\r\n// Using New Relic\r\nrequire('newrelic');\r\n\r\n// Using AppDynamics\r\nrequire('appdynamics').profile({\r\n  controllerHostName: 'your-controller',\r\n  controllerPort: 443,\r\n  accountName: 'your-account',\r\n  accountAccessKey: 'your-key',\r\n  applicationName: 'your-app'\r\n});\r\n```\r\n\r\n## Memory Management\r\n\r\n### 1. Avoiding Memory Leaks\r\n\r\n```javascript\r\n// Bad: Global variables that grow indefinitely\r\nlet cache = {};\r\napp.get('/user/:id', (req, res) => {\r\n  cache[req.params.id] = userData; // Memory leak!\r\n});\r\n\r\n// Good: Use proper caching with limits\r\nconst LRU = require('lru-cache');\r\nconst cache = new LRU({ max: 1000, ttl: 1000 * 60 * 10 });\r\n\r\napp.get('/user/:id', (req, res) => {\r\n  cache.set(req.params.id, userData);\r\n});\r\n```\r\n\r\n### 2. Proper Event Listener Management\r\n\r\n```javascript\r\n// Bad: Not removing event listeners\r\nfunction createHandler() {\r\n  const handler = () => { /* handle event */ };\r\n  eventEmitter.on('data', handler);\r\n  // Missing: eventEmitter.removeListener('data', handler);\r\n}\r\n\r\n// Good: Clean up event listeners\r\nfunction createHandler() {\r\n  const handler = () => { /* handle event */ };\r\n  eventEmitter.on('data', handler);\r\n  \r\n  return () => {\r\n    eventEmitter.removeListener('data', handler);\r\n  };\r\n}\r\n```\r\n\r\n### 3. Stream Processing for Large Data\r\n\r\n```javascript\r\nconst fs = require('fs');\r\nconst csv = require('csv-parser');\r\n\r\n// Bad: Loading entire file into memory\r\nfs.readFile('large-file.csv', (err, data) => {\r\n  const records = data.toString().split('\\n');\r\n  // Process all records at once\r\n});\r\n\r\n// Good: Stream processing\r\nfs.createReadStream('large-file.csv')\r\n  .pipe(csv())\r\n  .on('data', (row) => {\r\n    // Process one row at a time\r\n    processRow(row);\r\n  })\r\n  .on('end', () => {\r\n    console.log('CSV file successfully processed');\r\n  });\r\n```\r\n\r\n## Database Optimization\r\n\r\n### 1. Connection Pooling\r\n\r\n```javascript\r\n// MongoDB with connection pooling\r\nconst { MongoClient } = require('mongodb');\r\n\r\nconst client = new MongoClient(uri, {\r\n  maxPoolSize: 10,\r\n  serverSelectionTimeoutMS: 5000,\r\n  socketTimeoutMS: 45000,\r\n});\r\n\r\n// PostgreSQL with connection pooling\r\nconst { Pool } = require('pg');\r\nconst pool = new Pool({\r\n  user: 'username',\r\n  host: 'localhost',\r\n  database: 'mydb',\r\n  password: 'password',\r\n  port: 5432,\r\n  max: 20, // Maximum number of connections\r\n  idleTimeoutMillis: 30000,\r\n  connectionTimeoutMillis: 2000,\r\n});\r\n```\r\n\r\n### 2. Query Optimization\r\n\r\n```javascript\r\n// Bad: N+1 query problem\r\nasync function getPostsWithAuthors() {\r\n  const posts = await Post.find();\r\n  for (let post of posts) {\r\n    post.author = await User.findById(post.authorId);\r\n  }\r\n  return posts;\r\n}\r\n\r\n// Good: Use joins or populate\r\nasync function getPostsWithAuthors() {\r\n  return await Post.find().populate('author');\r\n}\r\n\r\n// Or with raw SQL\r\nasync function getPostsWithAuthors() {\r\n  const query = `\r\n    SELECT p.*, u.name as author_name \r\n    FROM posts p \r\n    JOIN users u ON p.author_id = u.id\r\n  `;\r\n  return await db.query(query);\r\n}\r\n```\r\n\r\n### 3. Indexing\r\n\r\n```javascript\r\n// MongoDB indexing\r\ndb.users.createIndex({ email: 1 });\r\ndb.posts.createIndex({ authorId: 1, createdAt: -1 });\r\n\r\n// Compound index for complex queries\r\ndb.products.createIndex({ \r\n  category: 1, \r\n  price: -1, \r\n  rating: -1 \r\n});\r\n```\r\n\r\n## Caching Strategies\r\n\r\n### 1. In-Memory Caching\r\n\r\n```javascript\r\nconst NodeCache = require('node-cache');\r\nconst cache = new NodeCache({ stdTTL: 600 }); // 10 minutes TTL\r\n\r\napp.get('/api/users/:id', async (req, res) => {\r\n  const userId = req.params.id;\r\n  const cacheKey = `user_${userId}`;\r\n  \r\n  // Check cache first\r\n  let user = cache.get(cacheKey);\r\n  \r\n  if (!user) {\r\n    // Fetch from database\r\n    user = await User.findById(userId);\r\n    \r\n    // Store in cache\r\n    cache.set(cacheKey, user);\r\n  }\r\n  \r\n  res.json(user);\r\n});\r\n```\r\n\r\n### 2. Redis Caching\r\n\r\n```javascript\r\nconst redis = require('redis');\r\nconst client = redis.createClient();\r\n\r\nasync function getCachedData(key) {\r\n  try {\r\n    const cached = await client.get(key);\r\n    return cached ? JSON.parse(cached) : null;\r\n  } catch (error) {\r\n    console.error('Cache error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\nasync function setCachedData(key, data, ttl = 3600) {\r\n  try {\r\n    await client.setex(key, ttl, JSON.stringify(data));\r\n  } catch (error) {\r\n    console.error('Cache error:', error);\r\n  }\r\n}\r\n\r\napp.get('/api/products', async (req, res) => {\r\n  const cacheKey = 'products_list';\r\n  \r\n  let products = await getCachedData(cacheKey);\r\n  \r\n  if (!products) {\r\n    products = await Product.find();\r\n    await setCachedData(cacheKey, products, 1800); // 30 minutes\r\n  }\r\n  \r\n  res.json(products);\r\n});\r\n```\r\n\r\n### 3. HTTP Caching\r\n\r\n```javascript\r\nconst express = require('express');\r\nconst app = express();\r\n\r\n// Cache static assets\r\napp.use('/static', express.static('public', {\r\n  maxAge: '1d', // Cache for 1 day\r\n  etag: true\r\n}));\r\n\r\n// Cache API responses\r\napp.get('/api/config', (req, res) => {\r\n  res.set('Cache-Control', 'public, max-age=3600'); // 1 hour\r\n  res.json(config);\r\n});\r\n\r\n// Conditional requests\r\napp.get('/api/data', (req, res) => {\r\n  const etag = generateETag(data);\r\n  \r\n  if (req.headers['if-none-match'] === etag) {\r\n    return res.status(304).end();\r\n  }\r\n  \r\n  res.set('ETag', etag);\r\n  res.json(data);\r\n});\r\n```\r\n\r\n## Asynchronous Programming Best Practices\r\n\r\n### 1. Avoid Blocking the Event Loop\r\n\r\n```javascript\r\n// Bad: Blocking operation\r\nfunction heavyComputation() {\r\n  let result = 0;\r\n  for (let i = 0; i < 10000000; i++) {\r\n    result += Math.random();\r\n  }\r\n  return result;\r\n}\r\n\r\napp.get('/compute', (req, res) => {\r\n  const result = heavyComputation(); // Blocks event loop\r\n  res.json({ result });\r\n});\r\n\r\n// Good: Use worker threads or break into chunks\r\nconst { Worker, isMainThread, parentPort } = require('worker_threads');\r\n\r\nif (isMainThread) {\r\n  app.get('/compute', (req, res) => {\r\n    const worker = new Worker(__filename);\r\n    worker.postMessage('start');\r\n    worker.on('message', (result) => {\r\n      res.json({ result });\r\n    });\r\n  });\r\n} else {\r\n  parentPort.on('message', () => {\r\n    const result = heavyComputation();\r\n    parentPort.postMessage(result);\r\n  });\r\n}\r\n```\r\n\r\n### 2. Proper Error Handling\r\n\r\n```javascript\r\n// Bad: Unhandled promise rejection\r\napp.get('/user/:id', (req, res) => {\r\n  User.findById(req.params.id)\r\n    .then(user => res.json(user));\r\n  // Missing .catch()\r\n});\r\n\r\n// Good: Proper error handling\r\napp.get('/user/:id', async (req, res) => {\r\n  try {\r\n    const user = await User.findById(req.params.id);\r\n    if (!user) {\r\n      return res.status(404).json({ error: 'User not found' });\r\n    }\r\n    res.json(user);\r\n  } catch (error) {\r\n    console.error('Error fetching user:', error);\r\n    res.status(500).json({ error: 'Internal server error' });\r\n  }\r\n});\r\n```\r\n\r\n### 3. Concurrent Operations\r\n\r\n```javascript\r\n// Bad: Sequential operations\r\nasync function fetchUserData(userId) {\r\n  const user = await User.findById(userId);\r\n  const posts = await Post.find({ authorId: userId });\r\n  const comments = await Comment.find({ authorId: userId });\r\n  \r\n  return { user, posts, comments };\r\n}\r\n\r\n// Good: Concurrent operations\r\nasync function fetchUserData(userId) {\r\n  const [user, posts, comments] = await Promise.all([\r\n    User.findById(userId),\r\n    Post.find({ authorId: userId }),\r\n    Comment.find({ authorId: userId })\r\n  ]);\r\n  \r\n  return { user, posts, comments };\r\n}\r\n```\r\n\r\n## HTTP Optimization\r\n\r\n### 1. Compression\r\n\r\n```javascript\r\nconst compression = require('compression');\r\n\r\napp.use(compression({\r\n  level: 6,\r\n  threshold: 1024,\r\n  filter: (req, res) => {\r\n    if (req.headers['x-no-compression']) {\r\n      return false;\r\n    }\r\n    return compression.filter(req, res);\r\n  }\r\n}));\r\n```\r\n\r\n### 2. Request Rate Limiting\r\n\r\n```javascript\r\nconst rateLimit = require('express-rate-limit');\r\n\r\nconst limiter = rateLimit({\r\n  windowMs: 15 * 60 * 1000, // 15 minutes\r\n  max: 100, // Limit each IP to 100 requests per windowMs\r\n  message: 'Too many requests from this IP',\r\n  standardHeaders: true,\r\n  legacyHeaders: false,\r\n});\r\n\r\napp.use('/api/', limiter);\r\n```\r\n\r\n### 3. Keep-Alive Connections\r\n\r\n```javascript\r\nconst http = require('http');\r\n\r\nconst server = http.createServer(app);\r\n\r\n// Enable keep-alive\r\nserver.keepAliveTimeout = 65000;\r\nserver.headersTimeout = 66000;\r\n\r\n// For outgoing requests\r\nconst agent = new http.Agent({\r\n  keepAlive: true,\r\n  keepAliveMsecs: 1000,\r\n  maxSockets: 50,\r\n  maxFreeSockets: 10\r\n});\r\n\r\nconst options = {\r\n  hostname: 'api.example.com',\r\n  port: 80,\r\n  path: '/data',\r\n  agent: agent\r\n};\r\n```\r\n\r\n## Production Optimizations\r\n\r\n### 1. Clustering\r\n\r\n```javascript\r\nconst cluster = require('cluster');\r\nconst numCPUs = require('os').cpus().length;\r\n\r\nif (cluster.isMaster) {\r\n  console.log(`Master ${process.pid} is running`);\r\n\r\n  // Fork workers\r\n  for (let i = 0; i < numCPUs; i++) {\r\n    cluster.fork();\r\n  }\r\n\r\n  cluster.on('exit', (worker, code, signal) => {\r\n    console.log(`Worker ${worker.process.pid} died`);\r\n    cluster.fork(); // Restart worker\r\n  });\r\n} else {\r\n  // Workers can share any TCP port\r\n  app.listen(3000, () => {\r\n    console.log(`Worker ${process.pid} started`);\r\n  });\r\n}\r\n```\r\n\r\n### 2. Process Management with PM2\r\n\r\n```javascript\r\n// ecosystem.config.js\r\nmodule.exports = {\r\n  apps: [{\r\n    name: 'my-app',\r\n    script: 'app.js',\r\n    instances: 'max',\r\n    exec_mode: 'cluster',\r\n    env: {\r\n      NODE_ENV: 'production',\r\n      PORT: 3000\r\n    },\r\n    error_file: './logs/err.log',\r\n    out_file: './logs/out.log',\r\n    log_file: './logs/combined.log',\r\n    time: true\r\n  }]\r\n};\r\n```\r\n\r\n### 3. Environment Variables\r\n\r\n```javascript\r\n// Use environment variables for configuration\r\nconst config = {\r\n  port: process.env.PORT || 3000,\r\n  dbUrl: process.env.DATABASE_URL,\r\n  redisUrl: process.env.REDIS_URL,\r\n  nodeEnv: process.env.NODE_ENV || 'development',\r\n  logLevel: process.env.LOG_LEVEL || 'info'\r\n};\r\n\r\n// Validate required environment variables\r\nconst requiredEnvVars = ['DATABASE_URL', 'REDIS_URL'];\r\nrequiredEnvVars.forEach(envVar => {\r\n  if (!process.env[envVar]) {\r\n    console.error(`Missing required environment variable: ${envVar}`);\r\n    process.exit(1);\r\n  }\r\n});\r\n```\r\n\r\n## Monitoring and Alerting\r\n\r\n### 1. Health Checks\r\n\r\n```javascript\r\napp.get('/health', async (req, res) => {\r\n  const health = {\r\n    status: 'OK',\r\n    timestamp: new Date().toISOString(),\r\n    uptime: process.uptime(),\r\n    memory: process.memoryUsage(),\r\n    version: process.version\r\n  };\r\n\r\n  try {\r\n    // Check database connection\r\n    await db.ping();\r\n    health.database = 'connected';\r\n  } catch (error) {\r\n    health.database = 'disconnected';\r\n    health.status = 'ERROR';\r\n  }\r\n\r\n  try {\r\n    // Check Redis connection\r\n    await redis.ping();\r\n    health.redis = 'connected';\r\n  } catch (error) {\r\n    health.redis = 'disconnected';\r\n    health.status = 'ERROR';\r\n  }\r\n\r\n  const statusCode = health.status === 'OK' ? 200 : 503;\r\n  res.status(statusCode).json(health);\r\n});\r\n```\r\n\r\n### 2. Performance Metrics\r\n\r\n```javascript\r\nconst promClient = require('prom-client');\r\n\r\n// Create metrics\r\nconst httpRequestDuration = new promClient.Histogram({\r\n  name: 'http_request_duration_seconds',\r\n  help: 'Duration of HTTP requests in seconds',\r\n  labelNames: ['method', 'route', 'status']\r\n});\r\n\r\nconst httpRequestsTotal = new promClient.Counter({\r\n  name: 'http_requests_total',\r\n  help: 'Total number of HTTP requests',\r\n  labelNames: ['method', 'route', 'status']\r\n});\r\n\r\n// Middleware to collect metrics\r\napp.use((req, res, next) => {\r\n  const start = Date.now();\r\n  \r\n  res.on('finish', () => {\r\n    const duration = (Date.now() - start) / 1000;\r\n    const labels = {\r\n      method: req.method,\r\n      route: req.route?.path || req.path,\r\n      status: res.statusCode\r\n    };\r\n    \r\n    httpRequestDuration.observe(labels, duration);\r\n    httpRequestsTotal.inc(labels);\r\n  });\r\n  \r\n  next();\r\n});\r\n\r\n// Metrics endpoint\r\napp.get('/metrics', (req, res) => {\r\n  res.set('Content-Type', promClient.register.contentType);\r\n  res.end(promClient.register.metrics());\r\n});\r\n```\r\n\r\n## Conclusion\r\n\r\nOptimizing Node.js applications requires a holistic approach that includes profiling, memory management, database optimization, caching, and proper deployment strategies. Start by identifying bottlenecks through profiling, then apply the appropriate optimization techniques.\r\n\r\nRemember that premature optimization can be counterproductive. Focus on measuring performance, identifying real bottlenecks, and then applying targeted optimizations. Regular monitoring and performance testing should be part of your development workflow to ensure your applications continue to perform well as they scale.\r\n\r\nThe key to successful Node.js performance optimization is understanding your application's specific requirements and bottlenecks, then applying the right combination of these techniques to achieve optimal performance.",
    "author": "Rohit Soni",
    "publishedAt": "2023-12-28",
    "readTime": 15,
    "tags": [
      "Node.js",
      "Performance",
      "Optimization",
      "Backend"
    ],
    "featured": false,
    "image": "nodejs-performance.jpg"
  }
];
